"""This modules contains the basic Generator classes."""

from __future__ import annotations

import sys
from abc import ABC
from abc import abstractmethod
from dataclasses import dataclass

# from typing import Self
from typing import Generic
from typing import TypeVar

from typing_extensions import Self


# region TypeVars used by generics

T = TypeVar("T", bool, str, float, int)
U = TypeVar("U", bool, str, float, int)
T_SFI = TypeVar("T_SFI", str, float, int)
T_BFI = TypeVar("T_BFI", bool, float, int)
T_FI = TypeVar("T_FI", float, int)
T_BI = TypeVar("T_BI", bool, int)
T_BF = TypeVar("T_BF", bool, float)
T_F = TypeVar("T_F", float, float)
T_B = TypeVar("T_B", bool, bool)
T_I = TypeVar("T_I", int, int)

if sys.version_info < (3, 10):

    def zip_strict(x: list[T], y: list[T]) -> zip[tuple[T, T]]:
        """Zip two lists together.

        Args:
            x (list[T]): The first list.
            y (list[T]): The second list.

        Returns:
            zip[tuple[T, T]]: The zipped lists.

        """
        return zip(x, y)  # noqa: B905

else:

    def zip_strict(x: list[T], y: list[T]) -> zip[tuple[T, T]]:
        """Zip two lists together.

        Args:
            x (list[T]): The first list.
            y (list[T]): The second list.

        Returns:
            zip[tuple[T, T]]: The zipped lists.

        """
        return zip(x, y, strict=True)


# endregion

# region Generic Abstract Classes


@dataclass
class Generator(Generic[T], ABC):
    """Basic Abstract Generator Class."""

    @abstractmethod
    def generate(self, n: int) -> list[T]:
        """Generate n values.

        Args:
            n (int): The number of values to generate.

        Returns:
            list[T]: The generated values.
        """
        ...

    @abstractmethod
    def copy(self) -> Self:
        """Create a copy of the Generator.

        Returns:
            Self: The copied Generator.
        """
        ...

    def to_int(self) -> GeneratorInt:
        """Convert the Generator to a Generator of integers.

        Returns:
            GeneratorInt: The converted Generator.
        """
        return GeneratorWrapperInt(self)

    def to_float(self) -> GeneratorFloat:
        """Convert the Generator to a Generator of floats.

        Returns:
            GeneratorFloat: The converted Generator.
        """
        return GeneratorWrapperFloat(self)

    def to_str(self) -> GeneratorStr:
        """Convert the Generator to a Generator of strings.

        Returns:
            GeneratorStr: The converted Generator.
        """
        return GeneratorWrapperStr(self)

    def to_bool(self) -> GeneratorBool:
        """Convert the Generator to a Generator of booleans.

        Returns:
            GeneratorBool: The converted Generator.
        """
        return GeneratorWrapperBool(self)


@dataclass
class GeneratorComposite(Generator[T], ABC):
    """A Composite Generator that combines two Generators.

    Args:
        left (Generator[T]): The left Generator.
        right (Generator[T]): The right Generator.
    """

    left: Generator[T]
    right: Generator[T]

    @abstractmethod
    def generate(self, n: int) -> list[T]:
        """Generate n values.

        Args:
            n (int): The number of values to generate.

        Returns:
            list[str]: The generated values.
        """
        ...

    def zip_generators(self, n: int) -> zip[tuple[T, T]]:
        """Zip the values generated by the two Generators.

        Args:
            n (int): The number of values to generate.

        Returns:
            zip[tuple[T, T]]: The zipped values.
        """
        lhs_values: list[T] = self.left.generate(n)
        rhs_values: list[T] = self.right.generate(n)
        return zip_strict(lhs_values, rhs_values)

    def copy(self) -> Self:
        """Create a copy of the GeneratorComposite.

        Returns:
            Self: The copied GeneratorComposite.
        """
        return self.__class__(self.left.copy(), self.right.copy())


@dataclass
class GeneratorWrapper(Generator[T], Generic[U, T], ABC):
    """A Wrapper class for converting Generators.

    Args:
        internal (Generator[U]): The internal Generator.
    """

    internal: Generator[U]

    def copy(self) -> Self:
        """Create a copy of the GeneratorWrapper.

        Returns:
            Self: The copied GeneratorWrapper.
        """
        return self.__class__(self.internal.copy())

    @staticmethod
    def convert(x: U, t: type[T]) -> T:
        """Convert the internal value to the response type.

        Args:
            x (U): The value to convert.
            t (type[T]): The type to convert to.

        Returns:
            T: The converted value.
        """
        try:
            return t(x)
        except ValueError:
            return t()

    def wrapper_generate(self, n: int, t: type[T]) -> list[T]:
        """Generate n values by converting the generated values to floats.

        Args:
            n (int):The number of values to generate.
            t (type[T]): The type to convert to.

        Returns:
            list[T]: The generated values.
        """
        return [GeneratorWrapper.convert(x, t) for x in self.internal.generate(n)]


@dataclass
class GeneratorConstant(Generator[T]):
    """A Generator that generates a constant value.

    Args:
        value (T): The constant value to generate.
    """

    value: T

    def generate(self, n: int) -> list[T]:
        """Generate n values.

        Args:
            n (int): The number of values to generate.

        Returns:
            list[T]: The generated values.
        """
        return [self.value for _ in range(n)]


# endregion

# region Abstract Typed Base Classes


@dataclass
class GeneratorBool(Generator[bool], ABC):
    """Abstract Base Class for Generators that generate booleans."""

    def to_bool(self) -> GeneratorBool:
        """Convert the Generator to a Generator of booleans.

        Returns:
            GeneratorBool: The converted Generator.
        """
        return self.copy()

    def __and__(self, other: GeneratorBool) -> GeneratorCompositeAndBool:
        """And the two GeneratorBools.

        Args:
            other (GeneratorBool): The other GeneratorBool.

        Returns:
            GeneratorCompositeAndBool: The Composite Generator.
        """
        return GeneratorCompositeAndBool(self, other)

    def __or__(self, other: GeneratorBool) -> GeneratorCompositeOrBool:
        """Or the two GeneratorBools.

        Args:
            other (GeneratorBool): The other GeneratorBool.

        Returns:
            GeneratorCompositeOrBool: The Composite Generator.
        """
        return GeneratorCompositeOrBool(self, other)

    def __xor__(self, other: GeneratorBool) -> GeneratorCompositeXorBool:
        """Xor the two GeneratorBools.

        Args:
            other (GeneratorBool): The other GeneratorBool.

        Returns:
            GeneratorCompositeXorBool: The Composite Generator.
        """
        return GeneratorCompositeXorBool(self, other)


@dataclass
class GeneratorStr(Generator[str], ABC):
    """Abstract Base Class for Generators that generate strings."""

    def to_str(self) -> GeneratorStr:
        """Convert the Generator to a Generator of strings.

        Returns:
            GeneratorStr: The converted Generator.
        """
        return self.copy()

    def __add__(self, other: GeneratorStr) -> GeneratorCompositeAddStr:
        """Add the two GeneratorStrs.

        Args:
            other (GeneratorStr): The other GeneratorStr.

        Returns:
            GeneratorCompositeAddStr: The Composite Generator.
        """
        return GeneratorCompositeAddStr(self, other)


@dataclass
class GeneratorFloat(Generator[float], ABC):
    """Abstract Base Class for Generators that generate floats."""

    def to_float(self) -> GeneratorFloat:
        """Convert the Generator to a Generator of floats.

        Returns:
            GeneratorFloat: The converted Generator.
        """
        return self.copy()

    def __add__(self, other: GeneratorFloat) -> GeneratorCompositeAddFloat:
        """Add the two GeneratorFloats.

        Args:
            other (GeneratorFloat): The other GeneratorFloat.

        Returns:
            GeneratorCompositeAddFloat: The Composite Generator.
        """
        return GeneratorCompositeAddFloat(self, other)

    def __sub__(self, other: GeneratorFloat) -> GeneratorCompositeSubFloat:
        """Subtract the two GeneratorFloats.

        Args:
            other (GeneratorFloat): The other GeneratorFloat.

        Returns:
            GeneratorCompositeSubFloat: The Composite Generator.
        """
        return GeneratorCompositeSubFloat(self, other)

    def __mul__(self, other: GeneratorFloat) -> GeneratorCompositeMultFloat:
        """Multiply the two GeneratorFloats.

        Args:
            other (GeneratorFloat): The other GeneratorFloat.

        Returns:
            GeneratorCompositeMultFloat: The Composite Generator.
        """
        return GeneratorCompositeMultFloat(self, other)

    def __truediv__(self, other: GeneratorFloat) -> GeneratorCompositeTrueDivFloat:
        """Divide the two GeneratorFloats.

        Args:
            other (GeneratorFloat): The other GeneratorFloat.

        Returns:
            GeneratorCompositeTrueDivFloat: The Composite Generator.
        """
        return GeneratorCompositeTrueDivFloat(self, other)

    def __floordiv__(self, other: GeneratorFloat) -> GeneratorCompositeFloorDivFloat:
        """Floor divide the two GeneratorFloat.

        Args:
            other (GeneratorFloat): The other GeneratorFloat.

        Returns:
            GeneratorCompositeFloorDivFloat: The Composite Generator.
        """
        return GeneratorCompositeFloorDivFloat(self, other)

    def __pow__(self, other: GeneratorFloat) -> GeneratorCompositePowFloat:
        """Exponentiate the two GeneratorFloats.

        Args:
            other (GeneratorFloat): The other GeneratorFloat.

        Returns:
            GeneratorCompositePowFloat: The Composite Generator.
        """
        return GeneratorCompositePowFloat(self, other)


@dataclass
class GeneratorInt(Generator[int], ABC):
    """Abstract Base Class for Generators that generate integers."""

    def to_int(self) -> GeneratorInt:
        """Convert the Generator to a Generator of integers.

        Returns:
            GeneratorInt: The converted Generator.
        """
        return self.copy()

    def __add__(self, other: GeneratorInt) -> GeneratorCompositeAddInt:
        """Add the two GeneratorInts.

        Args:
            other (GeneratorInt): The other GeneratorInt.

        Returns:
            GeneratorCompositeAddInt: The Composite Generator.
        """
        return GeneratorCompositeAddInt(self, other)

    def __sub__(self, other: GeneratorInt) -> GeneratorCompositeSubInt:
        """Subtract the two GeneratorInts.

        Args:
            other (GeneratorInt): The other GeneratorInt.

        Returns:
            GeneratorCompositeSubInt: The Composite Generator.
        """
        return GeneratorCompositeSubInt(self, other)

    def __mul__(self, other: GeneratorInt) -> GeneratorCompositeMultInt:
        """Multiply the two GeneratorInts.

        Args:
            other (GeneratorInt): The other GeneratorInt.

        Returns:
            GeneratorCompositeMultInt: The Composite Generator.
        """
        return GeneratorCompositeMultInt(self, other)

    def __floordiv__(self, other: GeneratorInt) -> GeneratorCompositeFloorDivInt:
        """Floor divide the two GeneratorInt.

        Args:
            other (GeneratorInt): The other GeneratorInt.

        Returns:
            GeneratorCompositeFloorDivInt: The Composite Generator.
        """
        return GeneratorCompositeFloorDivInt(self, other)

    def __pow__(self, other: GeneratorInt) -> GeneratorCompositePowInt:
        """Exponentiate the two GeneratorInts.

        Args:
            other (GeneratorInt): The other GeneratorInt.

        Returns:
            GeneratorCompositePowInt: The Composite Generator.
        """
        return GeneratorCompositePowInt(self, other)


# endregion

# region Wrapper Classes


@dataclass
class GeneratorWrapperStr(GeneratorStr, GeneratorWrapper[U, str]):
    """A Wrapper class for converting Generators to string Generators."""

    def generate(self, n: int) -> list[str]:
        """Generate n values by converting the generated values to strings.

        Args:
            n (int):The number of values to generate.

        Returns:
            list[str]: The generated values.
        """
        return self.wrapper_generate(n, str)


@dataclass
class GeneratorWrapperFloat(GeneratorFloat, GeneratorWrapper[U, float]):
    """A Wrapper class for converting Generators to float Generators."""

    def generate(self, n: int) -> list[float]:
        """Generate n values by converting the generated values to floats.

        Args:
            n (int):The number of values to generate.

        Returns:
            list[float]: The generated values.
        """
        return self.wrapper_generate(n, float)


@dataclass
class GeneratorWrapperInt(GeneratorInt, GeneratorWrapper[U, int]):
    """A Wrapper class for converting Generators to integer Generators."""

    def generate(self, n: int) -> list[int]:
        """Generate n values by converting the generated values to integers.

        Args:
            n (int):The number of values to generate.

        Returns:
            list[int]: The generated values.
        """
        return self.wrapper_generate(n, int)


@dataclass
class GeneratorWrapperBool(GeneratorBool, GeneratorWrapper[U, bool]):
    """A Wrapper class for converting Generators to boolean Generators."""

    def generate(self, n: int) -> list[bool]:
        """Generate n values by converting the generated values to booleans.

        Args:
            n (int):The number of values to generate.

        Returns:
            list[bool]: The generated values.
        """
        return self.wrapper_generate(n, bool)


# endregion

# region Abstract Typed Composite Classes


@dataclass
class GeneratorCompositeAdd(GeneratorComposite[T_SFI]):
    """A Composite Generator that adds two Generators."""

    def generate(self, n: int) -> list[T_SFI]:
        """Generate n values by adding the two generated values.

        Args:
            n (int):The number of values to generate.

        Returns:
            list[T_SFI]: The generated values.
        """
        return [a + b for a, b in self.zip_generators(n)]


@dataclass
class GeneratorCompositeSub(GeneratorComposite[T_FI]):
    """A Composite Generator that subtracts two Generators."""

    def generate(self, n: int) -> list[T_FI]:
        """Generate n values by subtracting the two generated values.

        Args:
            n (int):The number of values to generate.

        Returns:
            list[T_FI]: The generated values.
        """
        return [a - b for a, b in self.zip_generators(n)]


@dataclass
class GeneratorCompositeMult(GeneratorComposite[T_FI]):
    """A Composite Generator that multiplies two Generators."""

    def generate(self, n: int) -> list[T_FI]:
        """Generate n values by multiplying the two generated values.

        Args:
            n (int):The number of values to generate.

        Returns:
            list[T_FI]: The generated values.
        """
        return [a * b for a, b in self.zip_generators(n)]


@dataclass
class GeneratorCompositeTrueDiv(GeneratorComposite[T_F]):
    """A Composite Generator that divides two Generators."""

    def generate(self, n: int) -> list[T_F]:
        """Generate n values by dividing the two generated values.

        Args:
            n (int):The number of values to generate.

        Returns:
            list[T_F]: The generated values.
        """
        return [a / b for a, b in self.zip_generators(n)]


@dataclass
class GeneratorCompositeFloorDiv(GeneratorComposite[T_FI]):
    """A Composite Generator that floor divides two Generators."""

    def generate(self, n: int) -> list[T_FI]:
        """Generate n values by floor dividing the two generated values.

        Args:
            n (int):The number of values to generate.

        Returns:
            list[T_FI]: The generated values.
        """
        return [a // b for a, b in self.zip_generators(n)]


@dataclass
class GeneratorCompositePow(GeneratorComposite[T_FI]):
    """A Composite Generator that exponentiates two Generators."""

    def generate(self, n: int) -> list[T_FI]:
        """Generate n values by exponentiating the two generated values.

        Args:
            n (int):The number of values to generate.

        Returns:
            list[T_FI]: The generated values.
        """
        return [a**b for a, b in self.zip_generators(n)]


@dataclass
class GeneratorCompositeAnd(GeneratorComposite[T_B]):
    """A Composite Generator that ands two Generators."""

    def generate(self, n: int) -> list[T_B]:
        """Generate n values by anding the two generated values.

        Args:
            n (int):The number of values to generate.

        Returns:
            list[T_B]: The generated values.
        """
        return [a and b for a, b in self.zip_generators(n)]


@dataclass
class GeneratorCompositeOr(GeneratorComposite[T_B]):
    """A Composite Generator that ors two Generators."""

    def generate(self, n: int) -> list[T_B]:
        """Generate n values by oring the two generated values.

        Args:
            n (int):The number of values to generate.

        Returns:
            list[T_B]: The generated values.
        """
        return [a or b for a, b in self.zip_generators(n)]


@dataclass
class GeneratorCompositeXor(GeneratorComposite[T_B]):
    """A Composite Generator that xors two Generators."""

    def generate(self, n: int) -> list[T_B]:
        """Generate n values by xoring the two generated values.

        Args:
            n (int):The number of values to generate.

        Returns:
            list[T_B]: The generated values.
        """
        return [a ^ b for a, b in self.zip_generators(n)]


# endregion

# region Composite Classes

# region Composite Classes for Addition


@dataclass
class GeneratorCompositeAddStr(GeneratorStr, GeneratorCompositeAdd[str]):
    """A Composite Generator that adds two String Generators."""


@dataclass
class GeneratorCompositeAddFloat(GeneratorFloat, GeneratorCompositeAdd[float]):
    """A Composite Generator that adds two Float Generators."""


@dataclass
class GeneratorCompositeAddInt(GeneratorInt, GeneratorCompositeAdd[int]):
    """A Composite Generator that adds two Integer Generators."""


# endregion
# region Composite Classes for Subtraction


@dataclass
class GeneratorCompositeSubFloat(GeneratorFloat, GeneratorCompositeSub[float]):
    """A Composite Generator that subtracts two Float Generators."""


@dataclass
class GeneratorCompositeSubInt(GeneratorInt, GeneratorCompositeSub[int]):
    """A Composite Generator that subtracts two Integer Generators."""


# endregion
# region Composite Classes for Multiplication


@dataclass
class GeneratorCompositeMultFloat(GeneratorFloat, GeneratorCompositeMult[float]):
    """A Composite Generator that multiplies two Float Generators."""


@dataclass
class GeneratorCompositeMultInt(GeneratorInt, GeneratorCompositeMult[int]):
    """A Composite Generator that multiplies two Integer Generators."""


# endregion
# region Composite Classes for True Division


@dataclass
class GeneratorCompositeTrueDivFloat(GeneratorFloat, GeneratorCompositeTrueDiv[float]):
    """A Composite Generator that divides two Float Generators."""


# endregion
# region Composite Classes for Floor Division


@dataclass
class GeneratorCompositeFloorDivFloat(
    GeneratorCompositeFloorDiv[float], GeneratorFloat
):
    """A Composite Generator that floor divides two Float Generators."""


@dataclass
class GeneratorCompositeFloorDivInt(GeneratorInt, GeneratorCompositeFloorDiv[int]):
    """A Composite Generator that floor divides two Integer Generators."""


# endregion
# region Composite Classes for Power


@dataclass
class GeneratorCompositePowFloat(GeneratorFloat, GeneratorCompositePow[float]):
    """A Composite Generator that exponentiates two Float Generators."""


@dataclass
class GeneratorCompositePowInt(GeneratorInt, GeneratorCompositePow[int]):
    """A Composite Generator that exponentiates two Integer Generators."""


# endregion
# region Composite Classes for And


@dataclass
class GeneratorCompositeAndBool(GeneratorBool, GeneratorCompositeAnd[bool]):
    """A Composite Generator that ands two Boolean Generators."""


# endregion
# region Composite Classes for Or


@dataclass
class GeneratorCompositeOrBool(GeneratorBool, GeneratorCompositeOr[bool]):
    """A Composite Generator that ors two Boolean Generators."""


# endregion
# region Composite Classes for Xor


@dataclass
class GeneratorCompositeXorBool(GeneratorBool, GeneratorCompositeXor[bool]):
    """A Composite Generator that xors two Boolean Generators."""


# endregion

# endregion

# region Constant Generators


@dataclass
class ConstantStr(GeneratorStr, GeneratorConstant[str]):
    """A Generator that generates a constant string value."""


@dataclass
class ConstantBool(GeneratorBool, GeneratorConstant[bool]):
    """A Generator that generates a constant boolean value."""


@dataclass
class ConstantInt(GeneratorInt, GeneratorConstant[int]):
    """A Generator that generates a constant integer value."""


@dataclass
class ConstantFloat(GeneratorFloat, GeneratorConstant[float]):
    """A Generator that generates a constant float value."""


# endregion
